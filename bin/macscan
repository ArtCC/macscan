#!/bin/bash
# MacScan - Command-line malware scanner for macOS
# Main entry point

set -euo pipefail

# =============================================================================
# Script Setup
# =============================================================================

# Get the real path of the script (resolving symlinks)
get_script_dir() {
    local source="${BASH_SOURCE[0]}"
    while [[ -L "$source" ]]; do
        local dir
        dir="$(cd -P "$(dirname "$source")" && pwd)"
        source="$(readlink "$source")"
        [[ "$source" != /* ]] && source="$dir/$source"
    done
    cd -P "$(dirname "$source")" && pwd
}

# Determine script location (installed or development)
SCRIPT_DIR="$(get_script_dir)"

# Check if running from installed location or development
if [[ -f "${SCRIPT_DIR}/../lib/core/common.sh" ]]; then
    # Development mode - running from repo
    LIB_DIR="${SCRIPT_DIR}/../lib"
elif [[ -f "${HOME}/.config/macscan/lib/core/common.sh" ]]; then
    # Installed mode
    LIB_DIR="${HOME}/.config/macscan/lib"
else
    echo "Error: Cannot find MacScan libraries" >&2
    echo "Please reinstall MacScan or run from the source directory" >&2
    exit 1
fi

# =============================================================================
# Source Dependencies
# =============================================================================

source "${LIB_DIR}/core/common.sh"
source "${LIB_DIR}/ui/spinner.sh"
source "${LIB_DIR}/ui/progress.sh"
source "${LIB_DIR}/scan/clamav.sh"

# =============================================================================
# Global Cleanup / Signal Handling
# =============================================================================

# Ensure cursor is always restored on exit or interrupt
cleanup_on_exit() {
    show_cursor
    # Stop any running spinner
    if [[ -n "${_SPINNER_PID:-}" ]]; then
        kill -TERM "$_SPINNER_PID" 2>/dev/null || true
    fi
}

# Trap signals to ensure cleanup
trap cleanup_on_exit EXIT
trap 'cleanup_on_exit; exit 130' INT
trap 'cleanup_on_exit; exit 143' TERM

# =============================================================================
# Global Options
# =============================================================================

QUIET_MODE=0
NO_COLOR=0
DRY_RUN=0
NOTIFY=0
EXPORT_JSON=""

# Apply no-color mode if requested
apply_no_color() {
    if [[ $NO_COLOR -eq 1 ]]; then
        RED=''; GREEN=''; YELLOW=''; BLUE=''; PURPLE=''; CYAN=''
        WHITE=''; GRAY=''; BOLD=''; NC=''
        BOLD_RED=''; BOLD_GREEN=''; BOLD_YELLOW=''; BOLD_BLUE=''
        BOLD_PURPLE=''; BOLD_CYAN=''; BG_RED=''; BG_GREEN=''
        BG_YELLOW=''; BG_BLUE=''
    fi
}

# Quiet output wrapper
qlog() {
    [[ $QUIET_MODE -eq 0 ]] && echo -e "$@"
}

# Send macOS notification
send_notification() {
    local title="$1"
    local message="$2"
    local sound="${3:-default}"
    
    if [[ $NOTIFY -eq 1 ]]; then
        osascript -e "display notification \"$message\" with title \"$title\" sound name \"$sound\"" 2>/dev/null || true
    fi
}

# =============================================================================
# Help and Usage
# =============================================================================

show_help() {
    print_ascii_banner
    echo ""
    echo -e "${BOLD}USAGE:${NC}"
    echo "    macscan <command> [options]"
    echo "    ms <command> [options]"
    echo ""
    echo -e "${BOLD}COMMANDS:${NC}"
    echo "    scan              Quick scan of common threat locations"
    echo "    scan --path       Scan a specific directory"
    echo "    scan --full       Full system scan (takes longer)"
    echo "    update            Update virus database signatures"
    echo "    status            Show system status and last scan info"
    echo "    quarantine        Manage quarantined files"
    echo "    whitelist         Manage excluded paths"
    echo "    remove            Uninstall MacScan"
    echo "    help              Show this help message"
    echo "    version           Show version information"
    echo "    author            Show author information"
    echo ""
    echo -e "${BOLD}OPTIONS:${NC}"
    echo "    -p, --path <dir>  Specify directory to scan"
    echo "    -f, --full        Perform full system scan"
    echo "    -v, --verbose     Show detailed output"
    echo "    -q, --quiet       Suppress output (for scripts)"
    echo "    --dry-run         Show what would be scanned without scanning"
    echo "    --no-color        Disable colored output"
    echo "    --notify          Send macOS notification on completion"
    echo "    --export <file>   Export results to JSON file"
    echo "    -h, --help        Show help for a command"
    echo "    --version         Show version information"
    echo ""
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo "    ms scan                    # Quick scan"
    echo "    ms scan --path ~/Downloads # Scan specific folder"
    echo "    ms scan --full             # Full system scan"
    echo "    ms scan --quiet --notify   # Silent scan with notification"
    echo "    ms scan --dry-run          # Preview scan paths"
    echo "    ms update                  # Update virus signatures"
    echo "    ms status                  # Show scan status"
    echo "    ms whitelist add ~/safe    # Add path to whitelist"
    echo "    ms whitelist list          # View whitelisted paths"
    echo "    ms quarantine list         # List quarantined files"
    echo "    ms schedule daily 22:00    # Schedule daily scan at 22:00"
    echo "    ms schedule list           # View scheduled scans"
    echo "    ms remove                  # Uninstall MacScan"
    echo ""
    echo -e "${BOLD}CONFIGURATION:${NC}"
    echo "    Config:      ~/.config/macscan/"
    echo "    Data:        ~/.local/share/macscan/"
    echo "    Logs:        ~/.local/share/macscan/logs/"
    echo "    Quarantine:  ~/.local/share/macscan/quarantine/"
    echo ""
    echo -e "${BOLD}DISCLAIMER:${NC}"
    echo "    MacScan is provided \"as is\" without warranty of any kind. No antivirus"
    echo "    solution can detect 100% of malware. This tool is intended for educational"
    echo "    and supplementary security purposes only. It should not replace macOS"
    echo "    built-in security features (Gatekeeper, XProtect) or professional security"
    echo "    solutions. The authors are not responsible for any damage or data loss."
    echo "    Use at your own risk. Always maintain backups of important data."
    echo ""
    echo "For more information, visit: https://github.com/artcc/macscan"
    echo ""
}

show_version() {
    echo ""
    echo -e "  ${BOLD}${MACSCAN_NAME}${NC} v${MACSCAN_VERSION}"
    echo -e "  ${GRAY}${MACSCAN_DESCRIPTION}${NC}"
    echo ""
    echo -e "  ${GRAY}ClamAV: $(get_clamav_version)${NC}"
    echo ""
}

show_author() {
    echo ""
    echo -e "  ${BOLD}${CYAN}üë§ Author${NC}"
    echo ""
    echo -e "  ${BOLD}Arturo Carretero Calvo${NC}"
    echo ""
    echo -e "  ${GRAY}GitHub:${NC}   https://github.com/artcc"
    echo -e "  ${GRAY}Project:${NC}  https://github.com/artcc/macscan"
    echo ""
    echo -e "  ${GRAY}100% built with GitHub Copilot (Claude Opus 4.5)${NC}"
    echo -e "  ${GRAY}Made with ‚ù§Ô∏è for the macOS community ‚Äî 2026${NC}"
    echo ""
}

# =============================================================================
# Path Validation
# =============================================================================

# Validate and sanitize a path
validate_path() {
    local path="$1"
    
    # Expand ~ to home directory
    path="${path/#\~/$HOME}"
    
    # Resolve to absolute path
    if [[ -e "$path" ]]; then
        path="$(cd "$(dirname "$path")" && pwd)/$(basename "$path")"
    fi
    
    # Security: prevent path traversal attacks
    case "$path" in
        *../*|*/..*)
            log_error "Invalid path: contains '..'"
            return 1
            ;;
    esac
    
    # Check dangerous paths
    case "$path" in
        /|/System|/System/*|/usr|/bin|/sbin|/private|/private/*)
            log_warning "Scanning system directories may require elevated privileges"
            ;;
    esac
    
    echo "$path"
    return 0
}

# =============================================================================
# Commands
# =============================================================================

cmd_scan() {
    local path=""
    local full=0
    local verbose=0
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -p|--path)
                if [[ -n "${2:-}" ]]; then
                    path="$2"
                    shift 2
                else
                    log_error "Missing path argument"
                    exit 1
                fi
                ;;
            -f|--full)
                full=1
                shift
                ;;
            -v|--verbose)
                verbose=1
                shift
                ;;
            -q|--quiet)
                QUIET_MODE=1
                shift
                ;;
            --dry-run)
                DRY_RUN=1
                shift
                ;;
            --no-color)
                NO_COLOR=1
                apply_no_color
                shift
                ;;
            --notify)
                NOTIFY=1
                shift
                ;;
            --export)
                if [[ -n "${2:-}" ]]; then
                    EXPORT_JSON="$2"
                    shift 2
                else
                    log_error "Missing export file argument"
                    exit 1
                fi
                ;;
            -h|--help)
                echo ""
                echo "Usage: ms scan [options]"
                echo ""
                echo "Options:"
                echo "  -p, --path <dir>   Scan specific directory"
                echo "  -f, --full         Full system scan"
                echo "  -v, --verbose      Verbose output"
                echo "  -q, --quiet        Suppress output"
                echo "  --dry-run          Show what would be scanned"
                echo "  --no-color         Disable colors"
                echo "  --notify           Send macOS notification on completion"
                echo "  --export <file>    Export results to JSON"
                echo ""
                exit 0
                ;;
            *)
                # Check if it's a path
                if [[ -e "$1" ]]; then
                    path="$1"
                else
                    log_error "Unknown option: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    # Validate path if provided
    if [[ -n "$path" ]]; then
        path=$(validate_path "$path") || exit 1
        if [[ ! -e "$path" ]]; then
            log_error "Path does not exist: $path"
            exit 1
        fi
    fi
    
    # Check if database is outdated (more than 7 days)
    check_db_age
    
    # Ensure directories exist
    ensure_directories
    
    # Dry run mode - just show what would be scanned
    if [[ $DRY_RUN -eq 1 ]]; then
        show_dry_run "$path" "$full"
        return 0
    fi
    
    # Determine scan type and run
    local result=0
    if [[ $full -eq 1 ]]; then
        full_scan "$verbose" || result=$?
    elif [[ -n "$path" ]]; then
        scan_directory "$path" "$verbose" || result=$?
    else
        quick_scan "$verbose" || result=$?
    fi
    
    # Send notification if requested
    if [[ $NOTIFY -eq 1 ]]; then
        if [[ $result -eq 0 ]]; then
            send_notification "MacScan" "Scan complete - No threats found" "Glass"
        else
            send_notification "MacScan" "Scan complete - Threats detected!" "Basso"
        fi
    fi
    
    return $result
}

# Show dry run info
show_dry_run() {
    local path="$1"
    local full="$2"
    
    print_banner
    echo ""
    echo -e "  ${BOLD}${YELLOW}DRY RUN${NC} - No actual scanning will be performed"
    echo ""
    
    echo -e "  ${BOLD}Scan paths:${NC}"
    echo ""
    
    if [[ $full -eq 1 ]]; then
        for p in "${FULL_SCAN_PATHS[@]}"; do
            if [[ -d "$p" ]]; then
                local count
                count=$(count_files "$p")
                echo -e "  ${CYAN}${ICON_FOLDER}${NC} $p ${GRAY}(~$count files)${NC}"
            fi
        done
    elif [[ -n "$path" ]]; then
        if [[ -e "$path" ]]; then
            local count
            count=$(count_files "$path")
            echo -e "  ${CYAN}${ICON_FOLDER}${NC} $path ${GRAY}(~$count files)${NC}"
        fi
    else
        for p in "${DEFAULT_SCAN_PATHS[@]}"; do
            if [[ -d "$p" ]]; then
                local count
                count=$(find "$p" -maxdepth 2 -type f 2>/dev/null | wc -l | tr -d ' ')
                echo -e "  ${CYAN}${ICON_FOLDER}${NC} $p ${GRAY}(~$count files, depth 2)${NC}"
            fi
        done
    fi
    
    # Show whitelist if exists
    if [[ -f "$WHITELIST_FILE" ]] && [[ -s "$WHITELIST_FILE" ]]; then
        echo ""
        echo -e "  ${BOLD}Excluded paths (whitelist):${NC}"
        echo ""
        while IFS= read -r line || [[ -n "$line" ]]; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            echo -e "  ${GRAY}${ICON_ARROW}${NC} $line"
        done < "$WHITELIST_FILE"
    fi
    
    echo ""
    print_line 45
    echo ""
}

# Check database age and warn if outdated
check_db_age() {
    if [[ $QUIET_MODE -eq 1 ]]; then
        return 0
    fi
    
    if ! is_clamav_db_ready; then
        return 0
    fi
    
    # Use find instead of ls to handle filenames properly (SC2012)
    local latest
    latest=$(find "$CLAMAV_DB_PATH" -maxdepth 1 -name "*.cvd" -type f -print0 2>/dev/null | xargs -0 ls -t 2>/dev/null | head -n1)
    
    if [[ -n "$latest" ]]; then
        local mod_time
        mod_time=$(stat -f "%m" "$latest" 2>/dev/null)
        local now
        now=$(date +%s)
        local age_days=$(( (now - mod_time) / 86400 ))
        
        if [[ $age_days -gt 7 ]]; then
            log_warning "Virus database is $age_days days old. Run 'ms update' to update."
            echo ""
        fi
    fi
}

cmd_update() {
    ensure_directories
    update_database
}

cmd_status() {
    print_banner
    echo ""
    
    # System info
    echo -e "  ${BOLD}System Status${NC}"
    echo ""
    
    # ClamAV status
    if is_clamav_installed; then
        log_success "ClamAV installed"
        echo -e "     ${GRAY}$(get_clamav_version)${NC}"
    else
        log_error "ClamAV not installed"
        echo -e "     ${GRAY}Install with: brew install clamav${NC}"
    fi
    
    echo ""
    
    # Database status
    if is_clamav_db_ready; then
        log_success "Virus database ready"
        echo -e "     ${GRAY}$(get_db_info)${NC}"
    else
        log_warning "Virus database not initialized"
        echo -e "     ${GRAY}Run: ms update${NC}"
    fi
    
    echo ""
    
    # Last scan info
    echo -e "  ${BOLD}Last Scan${NC}"
    echo ""
    
    if [[ -f "$LAST_SCAN_FILE" ]]; then
        while IFS='=' read -r key value; do
            case "$key" in
                timestamp)
                    echo -e "  ${GRAY}Date:${NC} $value"
                    ;;
                path)
                    echo -e "  ${GRAY}Path:${NC} $value"
                    ;;
                files_scanned)
                    echo -e "  ${GRAY}Files:${NC} $value"
                    ;;
                threats_found)
                    if [[ "$value" == "0" ]]; then
                        echo -e "  ${GRAY}Threats:${NC} ${GREEN}$value${NC}"
                    else
                        echo -e "  ${GRAY}Threats:${NC} ${RED}$value${NC}"
                    fi
                    ;;
                duration)
                    echo -e "  ${GRAY}Duration:${NC} $(format_duration "$value")"
                    ;;
            esac
        done < "$LAST_SCAN_FILE"
    else
        echo -e "  ${GRAY}No previous scans found${NC}"
    fi
    
    echo ""
    print_line 45
    echo ""
}

# =============================================================================
# Quarantine Command
# =============================================================================

cmd_quarantine() {
    local action="${1:-list}"
    shift 2>/dev/null || true
    
    case "$action" in
        list)
            quarantine_list
            ;;
        restore)
            if [[ -z "${1:-}" ]]; then
                log_error "Missing file ID. Usage: ms quarantine restore <id>"
                exit 1
            fi
            quarantine_restore "$1"
            ;;
        delete)
            if [[ -z "${1:-}" ]]; then
                log_error "Missing file ID. Usage: ms quarantine delete <id>"
                exit 1
            fi
            quarantine_delete "$1"
            ;;
        clean)
            quarantine_clean
            ;;
        -h|--help|help)
            echo ""
            echo "Usage: ms quarantine <action> [options]"
            echo ""
            echo "Actions:"
            echo "  list              List quarantined files (default)"
            echo "  restore <id>      Restore a quarantined file"
            echo "  delete <id>       Permanently delete a quarantined file"
            echo "  clean             Delete all quarantined files"
            echo ""
            ;;
        *)
            log_error "Unknown quarantine action: $action"
            echo "Run 'ms quarantine help' for usage"
            exit 1
            ;;
    esac
}

# List quarantined files
quarantine_list() {
    print_banner
    echo ""
    echo -e "  ${BOLD}Quarantined Files${NC}"
    echo ""
    
    if [[ ! -d "$QUARANTINE_DIR" ]] || [[ -z "$(ls -A "$QUARANTINE_DIR" 2>/dev/null)" ]]; then
        echo -e "  ${GRAY}No files in quarantine${NC}"
        echo ""
        return 0
    fi
    
    local index=1
    local manifest="$QUARANTINE_DIR/.manifest"
    
    if [[ -f "$manifest" ]]; then
        while IFS='|' read -r id orig_path virus_name date; do
            local quarantined_file="$QUARANTINE_DIR/$id"
            if [[ -f "$quarantined_file" ]]; then
                echo -e "  ${YELLOW}[$index]${NC} ${RED}$virus_name${NC}"
                echo -e "      ${GRAY}Original:${NC} $orig_path"
                echo -e "      ${GRAY}Date:${NC} $date"
                echo -e "      ${GRAY}ID:${NC} $id"
                echo ""
                ((index++))
            fi
        done < "$manifest"
    else
        for file in "$QUARANTINE_DIR"/*; do
            [[ -f "$file" ]] || continue
            local filename
            filename=$(basename "$file")
            echo -e "  ${YELLOW}[$index]${NC} $filename"
            ((index++))
        done
    fi
    
    print_line 45
    echo ""
}

# Restore a quarantined file
quarantine_restore() {
    local file_id="$1"
    local manifest="$QUARANTINE_DIR/.manifest"
    
    if [[ ! -f "$manifest" ]]; then
        log_error "Quarantine manifest not found"
        return 1
    fi
    
    # Read manifest into memory to avoid SC2094 (read/write same file in pipeline)
    local manifest_content
    manifest_content=$(cat "$manifest")
    
    local found=0
    while IFS='|' read -r id orig_path virus_name date; do
        if [[ "$id" == "$file_id" ]]; then
            found=1
            local quarantined_file="$QUARANTINE_DIR/$id"
            
            if [[ ! -f "$quarantined_file" ]]; then
                log_error "Quarantined file not found: $id"
                return 1
            fi
            
            log_warning "This file was quarantined because it was detected as: $virus_name"
            echo -e "  ${GRAY}Original location:${NC} $orig_path"
            echo ""
            read -r -p "  Are you sure you want to restore this file? [y/N] " response
            
            if [[ "$response" =~ ^[yY]$ ]]; then
                local orig_dir
                orig_dir=$(dirname "$orig_path")
                mkdir -p "$orig_dir" 2>/dev/null
                
                if mv "$quarantined_file" "$orig_path"; then
                    # Remove from manifest (write new content)
                    echo "$manifest_content" | grep -v "^$id|" > "$manifest"
                    log_success "File restored to: $orig_path"
                else
                    log_error "Failed to restore file"
                    return 1
                fi
            else
                log_info "Restore cancelled"
            fi
            break
        fi
    done <<< "$manifest_content"
    
    if [[ $found -eq 0 ]]; then
        log_error "File ID not found: $file_id"
        return 1
    fi
}

# Delete a quarantined file
quarantine_delete() {
    local file_id="$1"
    local quarantined_file="$QUARANTINE_DIR/$file_id"
    local manifest="$QUARANTINE_DIR/.manifest"
    
    if [[ ! -f "$quarantined_file" ]]; then
        log_error "File not found in quarantine: $file_id"
        return 1
    fi
    
    read -r -p "  Permanently delete this file? [y/N] " response
    
    if [[ "$response" =~ ^[yY]$ ]]; then
        if rm -f "$quarantined_file"; then
            # Remove from manifest (avoid temp file)
            if [[ -f "$manifest" ]]; then
                local manifest_content
                manifest_content=$(cat "$manifest")
                echo "$manifest_content" | grep -v "^$file_id|" > "$manifest"
            fi
            log_success "File permanently deleted"
        else
            log_error "Failed to delete file"
            return 1
        fi
    else
        log_info "Delete cancelled"
    fi
}

# Clean all quarantined files
quarantine_clean() {
    if [[ ! -d "$QUARANTINE_DIR" ]] || [[ -z "$(ls -A "$QUARANTINE_DIR" 2>/dev/null)" ]]; then
        log_info "Quarantine is already empty"
        return 0
    fi
    
    # Validate quarantine directory
    if [[ -z "$QUARANTINE_DIR" || "$QUARANTINE_DIR" != *"macscan"* ]]; then
        log_error "Invalid quarantine directory configuration"
        return 1
    fi
    
    local count
    count=$(find "$QUARANTINE_DIR" -type f ! -name ".manifest" | wc -l | tr -d ' ')
    
    echo ""
    log_warning "This will permanently delete $count quarantined file(s)"
    echo -e "  ${GRAY}Directory:${NC} $QUARANTINE_DIR"
    echo ""
    read -r -p "  Are you sure? [y/N] " response
    
    if [[ ! "$response" =~ ^[yY]$ ]]; then
        log_info "Clean cancelled"
        return 0
    fi
    
    # Second confirmation for safety
    read -r -p "  Type 'DELETE' to confirm permanent deletion: " confirm_text
    
    if [[ "$confirm_text" != "DELETE" ]]; then
        log_info "Clean cancelled - confirmation text did not match"
        return 0
    fi
    
    rm -rf "${QUARANTINE_DIR:?}"/*
    log_success "Quarantine cleaned"
}

# Move file to quarantine
quarantine_file() {
    local file_path="$1"
    local virus_name="${2:-Unknown}"
    local auto_confirm="${3:-0}"
    
    # Always ask for confirmation unless explicitly auto-confirmed
    if [[ $auto_confirm -ne 1 ]]; then
        echo ""
        log_warning "Infected file detected: $file_path"
        echo -e "  ${GRAY}Threat:${NC} ${RED}$virus_name${NC}"
        echo ""
        read -r -p "  Move this file to quarantine? [y/N] " response
        
        if [[ ! "$response" =~ ^[yY]$ ]]; then
            log_info "File left in place: $file_path"
            return 0
        fi
    fi
    
    ensure_directories
    
    local file_id
    file_id=$(date +%s)_$(basename "$file_path" | tr ' ' '_')
    local dest="$QUARANTINE_DIR/$file_id"
    local manifest="$QUARANTINE_DIR/.manifest"
    
    # Validate destination directory
    if [[ -z "$QUARANTINE_DIR" || "$QUARANTINE_DIR" != *"macscan"* ]]; then
        log_error "Invalid quarantine directory configuration"
        return 1
    fi
    
    if mv "$file_path" "$dest"; then
        chmod 000 "$dest"  # Remove all permissions
        echo "$file_id|$file_path|$virus_name|$(date '+%Y-%m-%d %H:%M:%S')" >> "$manifest"
        log_success "File quarantined: $file_path"
        return 0
    else
        log_error "Failed to quarantine file: $file_path"
        return 1
    fi
}

# =============================================================================
# Whitelist Command
# =============================================================================

cmd_whitelist() {
    local action="${1:-list}"
    shift 2>/dev/null || true
    
    ensure_directories
    
    # Create whitelist if it doesn't exist
    if [[ ! -f "$WHITELIST_FILE" ]]; then
        cat > "$WHITELIST_FILE" << 'EOF'
# MacScan Whitelist
# Add paths to exclude from scanning (one per line)
# Lines starting with # are comments

# Example:
# /path/to/exclude
# ~/Library/Caches
EOF
    fi
    
    case "$action" in
        list)
            whitelist_list
            ;;
        add)
            whitelist_add "$@"
            ;;
        remove|rm)
            whitelist_remove "$@"
            ;;
        edit)
            whitelist_edit
            ;;
        -h|--help|help)
            echo ""
            echo "Usage: ms whitelist <command> [path]"
            echo ""
            echo "Commands:"
            echo "  list              List all whitelisted paths"
            echo "  add <path>        Add a path to whitelist"
            echo "  remove <path>     Remove a path from whitelist"
            echo "  edit              Open whitelist in editor"
            echo ""
            echo "Examples:"
            echo "  ms whitelist list"
            echo "  ms whitelist add ~/Library/Caches"
            echo "  ms whitelist remove ~/Library/Caches"
            echo "  ms whitelist edit"
            echo ""
            ;;
        *)
            log_error "Unknown whitelist action: $action"
            echo "Run 'ms whitelist help' for usage"
            return 1
            ;;
    esac
}

# List whitelisted paths
whitelist_list() {
    print_banner
    echo ""
    echo -e "  ${BOLD}Whitelisted Paths${NC}"
    echo ""
    
    if [[ ! -f "$WHITELIST_FILE" ]] || [[ ! -s "$WHITELIST_FILE" ]]; then
        echo -e "  ${GRAY}No paths in whitelist${NC}"
        echo ""
        echo -e "  Add paths with: ${CYAN}ms whitelist add <path>${NC}"
        echo ""
        return 0
    fi
    
    local count=0
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        # Trim whitespace
        line="${line#"${line%%[![:space:]]*}"}"
        line="${line%"${line##*[![:space:]]}"}"
        
        [[ -z "$line" ]] && continue
        
        ((count++))
        
        # Check if path exists
        if [[ -e "$line" ]]; then
            echo -e "  ${GREEN}${ICON_SUCCESS}${NC} $line"
        else
            echo -e "  ${YELLOW}${ICON_WARNING}${NC} $line ${GRAY}(path not found)${NC}"
        fi
    done < "$WHITELIST_FILE"
    
    echo ""
    if [[ $count -eq 0 ]]; then
        echo -e "  ${GRAY}No paths in whitelist${NC}"
    else
        echo -e "  ${GRAY}Total: $count path(s)${NC}"
    fi
    echo ""
}

# Add path to whitelist
whitelist_add() {
    local path="$1"
    
    if [[ -z "$path" ]]; then
        log_error "Missing path argument"
        echo "Usage: ms whitelist add <path>"
        return 1
    fi
    
    # Expand ~ to home directory
    path="${path/#\~/$HOME}"
    
    # Resolve to absolute path if exists
    if [[ -e "$path" ]]; then
        path="$(cd "$(dirname "$path")" && pwd)/$(basename "$path")"
    fi
    
    # Check if already in whitelist
    if grep -qFx "$path" "$WHITELIST_FILE" 2>/dev/null; then
        log_warning "Path already in whitelist: $path"
        return 0
    fi
    
    # Add to whitelist
    echo "$path" >> "$WHITELIST_FILE"
    log_success "Added to whitelist: $path"
    
    if [[ ! -e "$path" ]]; then
        log_warning "Note: Path does not currently exist"
    fi
}

# Remove path from whitelist
whitelist_remove() {
    local path="$1"
    
    if [[ -z "$path" ]]; then
        log_error "Missing path argument"
        echo "Usage: ms whitelist remove <path>"
        return 1
    fi
    
    # Expand ~ to home directory
    path="${path/#\~/$HOME}"
    
    # Check if in whitelist
    if ! grep -qF "$path" "$WHITELIST_FILE" 2>/dev/null; then
        log_warning "Path not in whitelist: $path"
        return 0
    fi
    
    # Remove from whitelist (create temp, then replace)
    local temp_file
    temp_file=$(mktemp)
    grep -vF "$path" "$WHITELIST_FILE" > "$temp_file"
    mv "$temp_file" "$WHITELIST_FILE"
    
    log_success "Removed from whitelist: $path"
}

# Open whitelist in editor
whitelist_edit() {
    local editor="${EDITOR:-nano}"
    
    log_info "Opening whitelist in $editor..."
    "$editor" "$WHITELIST_FILE"
}

# =============================================================================
# Scheduled Scans (launchd)
# =============================================================================

# Schedule command handler
cmd_schedule() {
    local action="$1"
    shift
    
    case "$action" in
        list)
            schedule_list
            ;;
        daily)
            schedule_create_daily "$@"
            ;;
        weekly)
            schedule_create_weekly "$@"
            ;;
        remove|rm)
            schedule_remove
            ;;
        -h|--help|help)
            echo ""
            echo "Usage: ms schedule <command> [options]"
            echo ""
            echo "Commands:"
            echo "  list                      Show current scheduled scan"
            echo "  daily HH:MM               Schedule daily scan at specified time"
            echo "  weekly <day> HH:MM        Schedule weekly scan on specified day"
            echo "  remove                    Remove scheduled scan"
            echo ""
            echo "Days: monday, tuesday, wednesday, thursday, friday, saturday, sunday"
            echo ""
            echo "Examples:"
            echo "  ms schedule daily 22:00"
            echo "  ms schedule weekly monday 03:00"
            echo "  ms schedule list"
            echo "  ms schedule remove"
            echo ""
            ;;
        "")
            schedule_list
            ;;
        *)
            log_error "Unknown schedule action: $action"
            echo "Run 'ms schedule help' for usage"
            return 1
            ;;
    esac
}

# List current scheduled scan
schedule_list() {
    local plist_file="$HOME/Library/LaunchAgents/com.macscan.scheduled.plist"
    
    print_banner
    echo ""
    echo -e "  ${BOLD}Scheduled Scan${NC}"
    echo ""
    
    if [[ ! -f "$plist_file" ]]; then
        echo -e "  ${GRAY}No scheduled scan configured${NC}"
        echo ""
        echo -e "  ${GRAY}Schedule a scan with:${NC}"
        echo -e "  ${CYAN}ms schedule daily HH:MM${NC}"
        echo -e "  ${CYAN}ms schedule weekly <day> HH:MM${NC}"
        echo ""
        return 0
    fi
    
    # Check if loaded
    local loaded
    loaded=$(launchctl list | grep "com.macscan.scheduled" 2>/dev/null)
    
    if [[ -n "$loaded" ]]; then
        echo -e "  ${GREEN}${ICON_SUCCESS}${NC} Active schedule"
    else
        echo -e "  ${YELLOW}${ICON_WARNING}${NC} Schedule exists but not loaded"
    fi
    
    # Extract schedule information using PlistBuddy
    local hour minute weekday
    hour=$(/usr/libexec/PlistBuddy -c "Print :StartCalendarInterval:Hour" "$plist_file" 2>/dev/null || echo "")
    minute=$(/usr/libexec/PlistBuddy -c "Print :StartCalendarInterval:Minute" "$plist_file" 2>/dev/null || echo "")
    weekday=$(/usr/libexec/PlistBuddy -c "Print :StartCalendarInterval:Weekday" "$plist_file" 2>/dev/null || echo "")
    
    if [[ -n "$hour" && -n "$minute" ]]; then
        if [[ -n "$weekday" ]]; then
            local day_name
            case "$weekday" in
                0) day_name="Sunday" ;;
                1) day_name="Monday" ;;
                2) day_name="Tuesday" ;;
                3) day_name="Wednesday" ;;
                4) day_name="Thursday" ;;
                5) day_name="Friday" ;;
                6) day_name="Saturday" ;;
            esac
            echo -e "  ${GRAY}Frequency:${NC} Weekly ($day_name)"
        else
            echo -e "  ${GRAY}Frequency:${NC} Daily"
        fi
        echo -e "  ${GRAY}Time:${NC} $(printf "%02d:%02d" "$hour" "$minute")"
    fi
    
    echo ""
    
    # Show last execution if log exists
    if [[ -f /tmp/macscan-scheduled.log ]]; then
        echo -e "  ${GRAY}Last execution:${NC}"
        tail -1 /tmp/macscan-scheduled.log 2>/dev/null | sed 's/^/    /' || echo "    No logs yet"
    fi
    
    echo ""
}

# Create daily schedule
schedule_create_daily() {
    local time="$1"
    local plist_file="$HOME/Library/LaunchAgents/com.macscan.scheduled.plist"
    
    if [[ -z "$time" ]]; then
        log_error "Missing time argument"
        echo "Usage: ms schedule daily HH:MM"
        return 1
    fi
    
    if [[ ! "$time" =~ ^[0-9]{1,2}:[0-9]{2}$ ]]; then
        log_error "Invalid time format. Use HH:MM (e.g., 22:00)"
        return 1
    fi
    
    local hour minute
    hour=$(echo "$time" | cut -d: -f1)
    minute=$(echo "$time" | cut -d: -f2)
    
    # Validate hour and minute
    if [[ $hour -lt 0 || $hour -gt 23 ]]; then
        log_error "Hour must be between 00 and 23"
        return 1
    fi
    
    if [[ $minute -lt 0 || $minute -gt 59 ]]; then
        log_error "Minute must be between 00 and 59"
        return 1
    fi
    
    # Check if schedule already exists
    if [[ -f "$plist_file" ]]; then
        echo ""
        read -r -p "  A schedule already exists. Replace it? [y/N] " response
        if [[ ! "$response" =~ ^[yY]$ ]]; then
            log_info "Cancelled"
            return 0
        fi
        # Unload existing schedule
        launchctl unload "$plist_file" 2>/dev/null
    fi
    
    # Create LaunchAgents directory if it doesn't exist
    mkdir -p "$HOME/Library/LaunchAgents"
    
    # Create plist file
    cat > "$plist_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.macscan.scheduled</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/local/bin/ms</string>
        <string>scan</string>
        <string>--quiet</string>
        <string>--notify</string>
    </array>
    <key>StartCalendarInterval</key>
    <dict>
        <key>Hour</key>
        <integer>$hour</integer>
        <key>Minute</key>
        <integer>$minute</integer>
    </dict>
    <key>StandardOutPath</key>
    <string>/tmp/macscan-scheduled.log</string>
    <key>StandardErrorPath</key>
    <string>/tmp/macscan-scheduled.err</string>
</dict>
</plist>
EOF
    
    # Load the schedule
    if launchctl load "$plist_file" 2>/dev/null; then
        log_success "Scheduled daily scan at $(printf "%02d:%02d" "$hour" "$minute")"
        echo ""
        echo -e "  ${GRAY}The scan will run quietly in the background${NC}"
        echo -e "  ${GRAY}You'll receive a notification when it completes${NC}"
        echo ""
    else
        log_error "Failed to load schedule"
        return 1
    fi
}

# Create weekly schedule
schedule_create_weekly() {
    local day="$1"
    local time="$2"
    local plist_file="$HOME/Library/LaunchAgents/com.macscan.scheduled.plist"
    
    if [[ -z "$day" || -z "$time" ]]; then
        log_error "Missing arguments"
        echo "Usage: ms schedule weekly <day> HH:MM"
        echo "Days: monday, tuesday, wednesday, thursday, friday, saturday, sunday"
        return 1
    fi
    
    # Convert day name to number
    local weekday
    case "${day,,}" in
        sunday|sun) weekday=0 ;;
        monday|mon) weekday=1 ;;
        tuesday|tue) weekday=2 ;;
        wednesday|wed) weekday=3 ;;
        thursday|thu) weekday=4 ;;
        friday|fri) weekday=5 ;;
        saturday|sat) weekday=6 ;;
        *)
            log_error "Invalid day: $day"
            echo "Valid days: monday, tuesday, wednesday, thursday, friday, saturday, sunday"
            return 1
            ;;
    esac
    
    if [[ ! "$time" =~ ^[0-9]{1,2}:[0-9]{2}$ ]]; then
        log_error "Invalid time format. Use HH:MM (e.g., 03:00)"
        return 1
    fi
    
    local hour minute
    hour=$(echo "$time" | cut -d: -f1)
    minute=$(echo "$time" | cut -d: -f2)
    
    # Validate hour and minute
    if [[ $hour -lt 0 || $hour -gt 23 ]]; then
        log_error "Hour must be between 00 and 23"
        return 1
    fi
    
    if [[ $minute -lt 0 || $minute -gt 59 ]]; then
        log_error "Minute must be between 00 and 59"
        return 1
    fi
    
    # Check if schedule already exists
    if [[ -f "$plist_file" ]]; then
        echo ""
        read -r -p "  A schedule already exists. Replace it? [y/N] " response
        if [[ ! "$response" =~ ^[yY]$ ]]; then
            log_info "Cancelled"
            return 0
        fi
        # Unload existing schedule
        launchctl unload "$plist_file" 2>/dev/null
    fi
    
    # Create LaunchAgents directory if it doesn't exist
    mkdir -p "$HOME/Library/LaunchAgents"
    
    # Create plist file
    cat > "$plist_file" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.macscan.scheduled</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/local/bin/ms</string>
        <string>scan</string>
        <string>--quiet</string>
        <string>--notify</string>
    </array>
    <key>StartCalendarInterval</key>
    <dict>
        <key>Weekday</key>
        <integer>$weekday</integer>
        <key>Hour</key>
        <integer>$hour</integer>
        <key>Minute</key>
        <integer>$minute</integer>
    </dict>
    <key>StandardOutPath</key>
    <string>/tmp/macscan-scheduled.log</string>
    <key>StandardErrorPath</key>
    <string>/tmp/macscan-scheduled.err</string>
</dict>
</plist>
EOF
    
    # Load the schedule
    if launchctl load "$plist_file" 2>/dev/null; then
        local day_name
        case "$weekday" in
            0) day_name="Sunday" ;;
            1) day_name="Monday" ;;
            2) day_name="Tuesday" ;;
            3) day_name="Wednesday" ;;
            4) day_name="Thursday" ;;
            5) day_name="Friday" ;;
            6) day_name="Saturday" ;;
        esac
        
        log_success "Scheduled weekly scan on $day_name at $(printf "%02d:%02d" "$hour" "$minute")"
        echo ""
        echo -e "  ${GRAY}The scan will run quietly in the background${NC}"
        echo -e "  ${GRAY}You'll receive a notification when it completes${NC}"
        echo ""
    else
        log_error "Failed to load schedule"
        return 1
    fi
}

# Remove scheduled scan
schedule_remove() {
    local plist_file="$HOME/Library/LaunchAgents/com.macscan.scheduled.plist"
    
    if [[ ! -f "$plist_file" ]]; then
        log_error "No scheduled scan found"
        return 1
    fi
    
    print_banner
    echo ""
    read -r -p "  Remove scheduled scan? [y/N] " response
    
    if [[ "$response" =~ ^[yY]$ ]]; then
        # Unload the schedule
        launchctl unload "$plist_file" 2>/dev/null
        
        # Remove the file
        rm -f "$plist_file"
        
        log_success "Scheduled scan removed"
    else
        log_info "Cancelled"
    fi
}

# =============================================================================
# Remove Command
# =============================================================================

cmd_remove() {
    echo ""
    echo -e "  ${BOLD}${RED}üõ°Ô∏è  MacScan Uninstaller${NC}"
    echo -e "  ${GRAY}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo ""
    
    echo "  This will remove:"
    echo ""
    echo -e "  ${GRAY}‚Ä¢${NC} ${INSTALL_DIR}/macscan"
    echo -e "  ${GRAY}‚Ä¢${NC} ${INSTALL_DIR}/ms"
    echo -e "  ${GRAY}‚Ä¢${NC} ${CONFIG_DIR}"
    echo -e "  ${GRAY}‚Ä¢${NC} ${DATA_DIR}"
    echo -e "  ${GRAY}‚Ä¢${NC} ${CACHE_DIR}"
    echo ""
    
    read -r -p "  Are you sure you want to uninstall MacScan? [y/N] " response
    
    if [[ ! "$response" =~ ^[yY]$ ]]; then
        echo ""
        log_info "Uninstall cancelled"
        return 0
    fi
    
    echo ""
    echo -e "${BOLD}Removing MacScan...${NC}"
    echo ""
    
    # Needs sudo check
    local needs_sudo=0
    [[ -e "$INSTALL_DIR" ]] && [[ ! -w "$INSTALL_DIR" ]] && needs_sudo=1
    
    if [[ $needs_sudo -eq 1 ]]; then
        log_info "Admin access required for ${INSTALL_DIR}"
    fi
    
    # Remove binaries
    if [[ -f "${INSTALL_DIR}/macscan" ]]; then
        if [[ $needs_sudo -eq 1 ]]; then
            sudo rm -f "${INSTALL_DIR}/macscan" && log_success "Removed macscan"
        else
            rm -f "${INSTALL_DIR}/macscan" && log_success "Removed macscan"
        fi
    fi
    
    if [[ -f "${INSTALL_DIR}/ms" ]]; then
        if [[ $needs_sudo -eq 1 ]]; then
            sudo rm -f "${INSTALL_DIR}/ms" && log_success "Removed ms"
        else
            rm -f "${INSTALL_DIR}/ms" && log_success "Removed ms"
        fi
    fi
    
    # Remove directories with validation
    if [[ -d "$CONFIG_DIR" ]]; then
        if [[ -z "$CONFIG_DIR" || "$CONFIG_DIR" != *"macscan"* ]]; then
            log_error "Invalid config directory, skipping"
        else
            read -r -p "  Remove configuration directory ($CONFIG_DIR)? [y/N] " response
            if [[ "$response" =~ ^[yY]$ ]]; then
                rm -rf "$CONFIG_DIR" && log_success "Removed $CONFIG_DIR"
            else
                log_info "Kept $CONFIG_DIR"
            fi
        fi
    fi
    
    if [[ -d "$DATA_DIR" ]]; then
        if [[ -z "$DATA_DIR" || "$DATA_DIR" != *"macscan"* ]]; then
            log_error "Invalid data directory, skipping"
        else
            read -r -p "  Remove data directory ($DATA_DIR)? [y/N] " response
            if [[ "$response" =~ ^[yY]$ ]]; then
                rm -rf "$DATA_DIR" && log_success "Removed $DATA_DIR"
            else
                log_info "Kept $DATA_DIR"
            fi
        fi
    fi
    
    if [[ -d "$CACHE_DIR" ]]; then
        if [[ -z "$CACHE_DIR" || "$CACHE_DIR" != *"macscan"* ]]; then
            log_error "Invalid cache directory, skipping"
        else
            read -r -p "  Remove cache directory ($CACHE_DIR)? [y/N] " response
            if [[ "$response" =~ ^[yY]$ ]]; then
                rm -rf "$CACHE_DIR" && log_success "Removed $CACHE_DIR"
            else
                log_info "Kept $CACHE_DIR"
            fi
        fi
    fi
    
    echo ""
    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "${GREEN}${ICON_SUCCESS}${NC} ${BOLD}MacScan has been uninstalled${NC}"
    echo -e "${GREEN}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo ""
    echo -e "  ${GRAY}ClamAV was not removed. To remove it:${NC}"
    echo -e "  ${CYAN}brew uninstall clamav${NC}"
    echo ""
}

# =============================================================================
# Interactive Menu
# =============================================================================

# Menu options
declare -a MENU_OPTIONS=(
    "Quick Scan|Scan common threat locations|cmd_quick_scan_menu"
    "Full Scan|Deep scan of your entire system|cmd_full_scan_menu"
    "Scan Path|Scan a specific directory|cmd_path_scan_menu"
    "Update|Update virus database signatures|cmd_update_menu"
    "Status|Show system status and last scan|cmd_status"
    "Quarantine|Manage quarantined files|cmd_quarantine_menu"
    "Whitelist|Manage excluded paths|cmd_whitelist_menu"
    "Schedule|Schedule automatic scans|cmd_schedule_menu"
)

# Menu wrapper functions
cmd_quick_scan_menu() {
    quick_scan 0
}

cmd_full_scan_menu() {
    full_scan 0
}

cmd_path_scan_menu() {
    echo ""
    echo -n -e "  ${BOLD}Enter path to scan:${NC} "
    read -r scan_path
    
    if [[ -z "$scan_path" ]]; then
        log_warning "No path entered"
        return 1
    fi
    
    scan_path="${scan_path/#\~/$HOME}"
    
    if [[ ! -e "$scan_path" ]]; then
        log_error "Path does not exist: $scan_path"
        return 1
    fi
    
    scan_directory "$scan_path" 0
}

cmd_update_menu() {
    update_database
}

cmd_quarantine_menu() {
    cmd_quarantine list
}

cmd_whitelist_menu() {
    cmd_whitelist list
}

cmd_schedule_menu() {
    cmd_schedule list
}

# Draw menu
draw_menu() {
    local selected=$1
    local num_options=${#MENU_OPTIONS[@]}
    
    # Clear screen and draw
    clear
    print_ascii_banner
    
    echo ""
    
    local i=0
    for option in "${MENU_OPTIONS[@]}"; do
        local label="${option%%|*}"
        local rest="${option#*|}"
        local desc="${rest%%|*}"
        local num=$((i + 1))
        
        if [[ $i -eq $selected ]]; then
            echo -e "  ${GREEN}‚ñ∂ ${num}. ${BOLD}${label}${NC}    ${GRAY}${desc}${NC}"
        else
            echo -e "    ${num}. ${label}    ${GRAY}${desc}${NC}"
        fi
        ((i++))
    done
    
    echo ""
    echo -e "  ${GRAY}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    echo -e "  ${GRAY}‚Üë‚Üì${NC} Navigate  ${GRAY}Enter${NC} Select  ${GRAY}H${NC} Help  ${GRAY}V${NC} Version  ${GRAY}A${NC} Author  ${GRAY}Q${NC} Quit"
}

# Interactive menu
show_interactive_menu() {
    local selected=0
    local num_options=${#MENU_OPTIONS[@]}
    
    # Hide cursor
    hide_cursor
    
    # Trap to restore cursor on exit
    trap 'show_cursor; echo ""' EXIT
    
    while true; do
        draw_menu $selected
        
        # Read single character
        local key
        IFS= read -rsn1 key
        
        case "$key" in
            # Arrow keys (escape sequences)
            $'\x1b')
                read -rsn2 -t 1 key
                case "$key" in
                    '[A') # Up arrow
                        ((selected--))
                        [[ $selected -lt 0 ]] && selected=$((num_options - 1))
                        ;;
                    '[B') # Down arrow
                        ((selected++))
                        [[ $selected -ge $num_options ]] && selected=0
                        ;;
                esac
                ;;
            # Number keys 1-9
            [1-9])
                local num=$((key - 1))
                if [[ $num -lt $num_options ]]; then
                    selected=$num
                    # Execute immediately
                    show_cursor
                    clear
                    local option="${MENU_OPTIONS[$selected]}"
                    local func="${option##*|}"
                    $func
                    echo ""
                    echo -e "  ${GRAY}Press any key to continue...${NC}"
                    read -rsn1
                    hide_cursor
                fi
                ;;
            # Enter key
            '')
                show_cursor
                clear
                local option="${MENU_OPTIONS[$selected]}"
                local func="${option##*|}"
                $func
                echo ""
                echo -e "  ${GRAY}Press any key to continue...${NC}"
                read -rsn1
                hide_cursor
                ;;
            # Help
            h|H)
                show_cursor
                clear
                show_help
                echo ""
                echo -e "  ${GRAY}Press any key to continue...${NC}"
                read -rsn1
                hide_cursor
                ;;
            # Quit
            q|Q)
                show_cursor
                clear
                echo ""
                echo -e "  ${GRAY}Goodbye! Stay safe. üõ°Ô∏è${NC}"
                echo ""
                exit 0
                ;;
            # Author
            a|A)
                show_cursor
                clear
                show_author
                echo ""
                echo -e "  ${GRAY}Press any key to continue...${NC}"
                read -rsn1
                hide_cursor
                ;;
            # Version
            v|V)
                show_cursor
                clear
                show_version
                echo ""
                echo -e "  ${GRAY}Press any key to continue...${NC}"
                read -rsn1
                hide_cursor
                ;;
        esac
    done
}

# =============================================================================
# Main Entry Point
# =============================================================================

main() {
    # Check if running on macOS
    if ! is_macos; then
        log_error "MacScan is designed for macOS only"
        exit 1
    fi
    
    # No arguments - show interactive menu
    if [[ $# -eq 0 ]]; then
        show_interactive_menu
        exit 0
    fi
    
    # Parse command
    local command="$1"
    shift
    
    case "$command" in
        scan)
            cmd_scan "$@"
            ;;
        update)
            cmd_update "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        quarantine)
            cmd_quarantine "$@"
            ;;
        whitelist)
            cmd_whitelist "$@"
            ;;
        schedule)
            cmd_schedule "$@"
            ;;
        remove|uninstall)
            cmd_remove "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        version|--version|-V)
            show_version
            ;;
        author)
            show_author
            ;;
        *)
            log_error "Unknown command: $command"
            echo ""
            echo "Run 'ms help' for usage information"
            exit 1
            ;;
    esac
}

# Run main
main "$@"
